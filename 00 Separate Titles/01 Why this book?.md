# Why this book?

The short answer is that I believe Nix and the community deserve it.
Despite all the well-known flaws,
Nix is still by far the most beautiful tool for software building and deploying
and is widely used in narrow circles,
mostly among Haskell developers.

I want to help widen these circles a bit by creating a top-notch learning book
that will finally break the notorious "steep learning curve".
This happens to have some historical reasons.
Nix started in 2003 as a research project of Eelco Dolstra at Utrecht University
and by now there thrives a whole ecosystem with more than 600+ people
in the NixOS organization on GitHub
and a plethora of related projects.

Being community-driven brings many advantages,
but also tends to focus on solving the members' immediate tasks
rather than building a product and taking care of users.
As a result, we have a great heritage that includes tons of documentation,
but it's still rather hard to see the forest for the trees.

The number one reason is just the size.
It's easy to get lost without guidance.
Nix is used for different tasks, with different languages,
on different hardware, and by different people.
Time is also a factor;
many things have changed over almost twenty years and are outdated.
Some parts have no documentation
or have only sparse notes which quite often
can be understood only by those who have already come to grips with Nix.
This fact is even got reflected in Nix folklore.
"Absence of documentation is a key feature of Nix,
on a par with laziness and pure functional builds."
Having no intentions of ridding Nix of said key feature,
this book, the other way around,
is justified because "having good learning material"
or "having at least one book" would be another key feature in itself.
"The more Nix books â€” the merrier," said an author of another book on Nix.

Why do I consider myself a good fit for the author role?
First of all, I'd like to exploit my interest in Nix
and convert it into something wholesome for others.
Then, having quite extensive experience in the software development industry
including functional programming,
I am still a newcomer to Nix.
I am going to leverage this combination to avoid writing a book
for those who have already made their way to Nix.
And last but not least - I have personal accounts to settle with Nix.

I started working as a Haskell developer several years ago
and bumped into Nix.
I remember the feeling of frustration
when a colleague of mine introduced us to Nix.
Everyone on our team preferred to stay as far away from Nix as possible.
But not me.
When that guy left out team,
I faced the necessity to maintain Nix bits of a tailored building tool
for a pretty big project.
It was torture since I couldn't find a way to learn
what I needed in a reasonable amount of time.
In my subsequent encounter with Nix,
I was working on the deployment tasks,
and this time I was much luckier
because the team had pretty good expertise in the area.
It helped a lot and I wish the gained knowledge will not vanish into oblivion.

I would highly appreciate any pieces of advice, the community's wishes,
and, of course, your support in this endeavor.

For the time being, I am in the middle of the process of initially gathering materials,
talking to the community, and thinking through the outline of the book
which I gave a working title "Developing and Deploying with Nix".